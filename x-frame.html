<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Clickjacking / Frameability Test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 20px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .row { margin: 12px 0; }
    label { display:inline-block; width: 110px; }
    input[type=text] { width: 60%; padding:6px; }
    button { padding:6px 10px; }
    #result { margin-top:14px; padding:12px; border-radius:8px; background:#f3f3f3; }
    #iframeWrap { margin-top:12px; border:1px solid #ddd; height:420px; width:100%; max-width:980px; }
    iframe { width:100%; height:100%; border:0; }
    .ok { color: #0a0; font-weight:700; }
    .bad { color: #a00; font-weight:700; }
    small { color:#555; display:block; margin-top:6px; }
  </style>
</head>
<body>
  <h1>Clickjacking / Frameability Test</h1>
  <div class="row">
    <label for="url">Target URL</label>
    <input id="url" type="text" placeholder="https://example.com" />
    <button id="checkBtn">Test</button>
  </div>

  <div id="result">
    <div id="status">Enter a URL and press <strong>Test</strong>.</div>
    <small>Note: due to browser security rules some checks are approximations — read notes below.</small>
  </div>

  <div id="iframeWrap" aria-hidden="true"></div>

  <script>
    // Utility: read ?url=... from query string if present
    function getQueryUrl() {
      const params = new URLSearchParams(location.search);
      const u = params.get('url');
      return u;
    }

    const urlInput = document.getElementById('url');
    const checkBtn = document.getElementById('checkBtn');
    const status = document.getElementById('status');
    const iframeWrap = document.getElementById('iframeWrap');

    // If a ?url= is given, fill it
    const qUrl = getQueryUrl();
    if (qUrl) urlInput.value = qUrl;

    checkBtn.addEventListener('click', () => {
      const target = urlInput.value.trim();
      if (!target) {
        status.innerHTML = '<span class="bad">Please provide a valid URL</span>';
        return;
      }
      runTest(target);
    });

    async function runTest(targetUrl) {
      // Clear previous iframe
      iframeWrap.innerHTML = '';
      status.textContent = 'Testing — creating iframe...';

      // Create iframe and add to page
      const ifr = document.createElement('iframe');
      // Optional: add sandbox to limit any harmful behavior (no scripts, no forms).
      // But DO NOT add sandbox if you want to test real framing behavior (sandbox may constrain it).
      // ifr.setAttribute('sandbox', 'allow-same-origin'); // commented by default
      ifr.src = targetUrl;
      iframeWrap.appendChild(ifr);

      // Wait for either load or timeout
      const timedOut = await new Promise(resolve => {
        let resolved = false;
        // onload handler
        ifr.onload = () => {
          if (resolved) return;
          resolved = true;
          resolve(false); // not timed out
        };
        // onerror rarely fires for blocked frames; keep timeout fallback
        ifr.onerror = () => {
          if (resolved) return;
          resolved = true;
          resolve(false);
        };
        // timeout (5s)
        setTimeout(() => {
          if (resolved) return;
          resolved = true;
          resolve(true);
        }, 5000);
      });

      // Heuristic detection:
      // 1) If the browser prevents framing via X-Frame-Options / frame-ancestors, many browsers will
      //    load about:blank in the iframe instead of the target. In that case reading iframe.contentWindow.location.href succeeds and is "about:blank".
      // 2) If the target is framed successfully but is cross-origin, accessing iframe.contentWindow.location.href will throw a SecurityError (caught).
      // 3) If same-origin (rare for remote target) you can access the location and compare.
      let message = '';
      try {
        // Try to read location.href of the iframe's window (may throw if cross-origin)
        const href = iframeWrap.querySelector('iframe').contentWindow.location.href;
        // If we got here without exception, either:
        //  - iframe loaded same-origin page (uncommon) OR
        //  - the browser replaced frame with about:blank (blocked) — either case href is readable.
        if (href === 'about:blank' || href === '' || href === 'chrome-error://') {
          message = `<span class="bad">Blocked from framing.</span> Browser prevented embedding the target (likely via <code>X-Frame-Options</code> or <code>frame-ancestors</code>).`;
        } else {
          // If href equals the targetUrl or resolves to it (same-origin), framing succeeded and we can consider it frameable.
          // Normalize small differences by comparing origins
          const targetOrigin = (new URL(targetUrl)).origin;
          const frameOrigin = (new URL(href)).origin;
          if (targetOrigin === frameOrigin) {
            message = `<span class="bad">Framed (same-origin).</span> The page was embedded successfully and is same-origin with the tester page — it is frameable (clickjacking risk).`;
          } else {
            // different origin but readable location — unusual; flag as frameable.
            message = `<span class="ok">Framed.</span> The iframe loaded content and returned a readable location: <code>${escapeHtml(href)}</code>. This indicates framing succeeded and the page may be vulnerable to clickjacking.`;
          }
        }
      } catch (ex) {
        // Accessing location threw — which usually means the iframe loaded the target and is cross-origin.
        // That's the risky case: the target allowed embedding and prevents us from inspecting by same-origin policy
        message = `<span class="ok">Framed (cross-origin).</span> The iframe loaded the target and access is blocked by browser same-origin rules — framing succeeded, so the page <strong>may be vulnerable</strong> to clickjacking unless other mitigations exist.`;
      }

      // If we timed out and we couldn't detect anything, warn the user
      if (timedOut) {
        message += ' <small>(Note: detection timed out — try again or increase the timeout if the site is slow to respond.)</small>';
      }

      // Show result
      status.innerHTML = message + '<br/><small>Read the notes below for limitations and next steps.</small>';
    }

    function escapeHtml(s) {
      if (!s) return '';
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // Auto-run if URL parameter present
    if (qUrl) {
      // small delay to let control render
      setTimeout(() => { checkBtn.click(); }, 250);
    }
  </script>

  <hr style="margin-top:18px" />
  <h3>How this works (short)</h3>
  <ul>
    <li>This page attempts to embed the <strong>target URL</strong> inside an <code>&lt;iframe&gt;</code>.</li>
    <li>If the browser refuses to frame the target (because of <code>X-Frame-Options: DENY</code>, <code>SAMEORIGIN</code>, or CSP <code>frame-ancestors</code>), the iframe often becomes <code>about:blank</code> and is readable from the parent page — the script detects that and reports "Blocked".</li>
    <li>If the iframe loads the target and the parent cannot read its location (throws cross-origin access error), that indicates the target was framed successfully — a potential clickjacking risk.</li>
  </ul>

  <h4>Limitations and notes</h4>
  <ul>
    <li>Browser behaviors vary slightly across versions. This is a heuristic test — consider validating the presence of headers on the server side as well.</li>
    <li>Some sites intentionally allow framing for select origins (via <code>frame-ancestors</code>) — that will show up as "Framed (cross-origin)".</li>
    <li>To be certain, check the response headers for <code>Content-Security-Policy</code> (look for <code>frame-ancestors</code>) and <code>X-Frame-Options</code> using <code>curl -I</code> or in Burp/DevTools.</li>
    <li>If the target sends a CSP frame-ancestors directive you won't be able to override it by HTML — the browser enforces it.</li>
  </ul>

  <h4>Next steps / manual checks</h4>
  <ol>
    <li>Check headers: <code>curl -I -L https://target.example</code> and look for <code>X-Frame-Options</code> and <code>Content-Security-Policy</code> (frame-ancestors).</li>
    <li>Try framing from a page with a different origin to emulate an attacker-controlled page.</li>
    <li>If the site is frameable and you control the site, add one of:
      <ul>
        <li><code>X-Frame-Options: DENY</code> (basic, legacy)</li>
        <li><code>X-Frame-Options: SAMEORIGIN</code> (allows same-origin frames)</li>
        <li><code>Content-Security-Policy: frame-ancestors 'self'</code> (modern and flexible)</li>
      </ul>
    </li>
  </ol>

</body>
</html>
